--- a/sql/memory/aligned_atomic.h	2023-06-22 13:07:42.000000000 +0200
+++ b/sql/memory/aligned_atomic.h	2023-08-27 20:34:26.244493105 +0200
@@ -38,9 +38,8 @@
 #include <unistd.h>
 #endif
 
-#include "my_aligned_malloc.h"
-
 namespace memory {
+
 /**
  Calculates and returns the size of the CPU cache line.
 
@@ -259,28 +258,14 @@
 
     @return The pointer to the underlying `std::atomic<T>` object.
    */
-  std::atomic<T> *operator->();
-  /*
-    Pointer operator that allows the access to the underlying `std::atomic<T>`
-    object.
-
-    @return The const pointer to the underlying `std::atomic<T>` object.
-   */
-  const std::atomic<T> *operator->() const;
+  std::atomic<T> *operator->() const;
   /*
     Dereference operator that allows the access to the underlying
     `std::atomic<T>` object.
 
     @return The reference to the underlying `std::atomic<T>` object.
    */
-  std::atomic<T> &operator*();
-  /*
-    Dereference operator that allows the access to the underlying
-    `std::atomic<T>` object.
-
-    @return The const reference to the underlying `std::atomic<T>` object.
-   */
-  const std::atomic<T> &operator*() const;
+  std::atomic<T> &operator*() const;
   /*
     The size of `std::atomic<T>`, as returned by `sizeof std::atomic<T>`.
 
@@ -298,7 +283,7 @@
   /** The size of the byte buffer. */
   size_t m_storage_size{0};
   /** The byte buffer to use as underlying storage. */
-  void *m_storage{nullptr};
+  alignas(std::max_align_t) unsigned char *m_storage{nullptr};
   /** The pointer to the underlying `std::atomic<T>` object. */
   std::atomic<T> *m_underlying{nullptr};
 };
@@ -306,10 +291,9 @@
 
 template <typename T>
 memory::Aligned_atomic<T>::Aligned_atomic()
-    : m_storage_size{memory::minimum_cacheline_for<std::atomic<T>>()} {
-  m_storage = my_aligned_malloc(m_storage_size, cache_line_size());
-  m_underlying = new (this->m_storage) std::atomic<T>();
-}
+    : m_storage_size{memory::minimum_cacheline_for<std::atomic<T>>()},
+      m_storage{new unsigned char[m_storage_size]},
+      m_underlying{new (this->m_storage) std::atomic<T>()} {}
 
 template <typename T>
 memory::Aligned_atomic<T>::Aligned_atomic(T value)
@@ -318,16 +302,12 @@
 }
 
 template <typename T>
-memory::Aligned_atomic<T>::Aligned_atomic(Aligned_atomic<T> &&rhs) {
-  if (this->m_underlying != nullptr) {
-    this->m_underlying->~atomic();
-  }
-  my_aligned_free(this->m_storage);
+memory::Aligned_atomic<T>::Aligned_atomic(Aligned_atomic<T> &&rhs)
+    : m_storage_size{rhs.m_storage_size}, m_underlying{rhs.m_underlying} {
+  delete[] this->m_storage;
   this->m_storage = rhs.m_storage;
-  this->m_storage_size = rhs.m_storage_size;
-  this->m_underlying = rhs.m_underlying;
-  rhs.m_storage = nullptr;
   rhs.m_storage_size = 0;
+  rhs.m_storage = nullptr;
   rhs.m_underlying = nullptr;
 }
 
@@ -335,25 +315,22 @@
 memory::Aligned_atomic<T>::~Aligned_atomic() {
   if (this->m_underlying != nullptr) {
     this->m_underlying->~atomic();
+    this->m_underlying = nullptr;
   }
-  my_aligned_free(this->m_storage);
+  delete[] this->m_storage;
   this->m_storage = nullptr;
   this->m_storage_size = 0;
-  this->m_underlying = nullptr;
 }
 
 template <typename T>
 memory::Aligned_atomic<T> &memory::Aligned_atomic<T>::operator=(
     Aligned_atomic<T> &&rhs) {
-  if (this->m_underlying != nullptr) {
-    this->m_underlying->~atomic();
-  }
-  my_aligned_free(this->m_storage);
-  this->m_storage = rhs.m_storage;
+  delete[] this->m_storage;
   this->m_storage_size = rhs.m_storage_size;
+  this->m_storage = rhs.m_storage;
   this->m_underlying = rhs.m_underlying;
-  rhs.m_storage = nullptr;
   rhs.m_storage_size = 0;
+  rhs.m_storage = nullptr;
   rhs.m_underlying = nullptr;
   return (*this);
 }
@@ -393,25 +370,13 @@
 }
 
 template <typename T>
-std::atomic<T> *memory::Aligned_atomic<T>::operator->() {
-  assert(this->m_underlying != nullptr);
-  return this->m_underlying;
-}
-
-template <typename T>
-const std::atomic<T> *memory::Aligned_atomic<T>::operator->() const {
+std::atomic<T> *memory::Aligned_atomic<T>::operator->() const {
   assert(this->m_underlying != nullptr);
   return this->m_underlying;
 }
 
 template <typename T>
-std::atomic<T> &memory::Aligned_atomic<T>::operator*() {
-  assert(this->m_underlying != nullptr);
-  return *this->m_underlying;
-}
-
-template <typename T>
-const std::atomic<T> &memory::Aligned_atomic<T>::operator*() const {
+std::atomic<T> &memory::Aligned_atomic<T>::operator*() const {
   assert(this->m_underlying != nullptr);
   return *this->m_underlying;
 }
